########## Testcase 0: Failed ##########
Expected Output: 
0.0

Your Output: 
weve been showing you a lot of great tools in computation weve introduced simple data objects weve introduced compound data objects weve introduced iteration weve introduced recursion weve talked about using functions in a variety of ways you now have a lot of the tools you need to have in order to build interesting code and in fact weve been asking to do that in the problem sets that you have been working on as youve gone through this course but we now come to a place where we have to be a little more clever because youve probably already experienced problems with your code bugs have wandered in that you werent expecting they have done things that you didnt want to have happen inside of the code and so were going to now turn to a question that every computer programmer faces which is how do i test my code and when it doesnt work the way i expected it to how do i go about debugging it and thats what this lectures going to be all about now one of the things that happens with debugging is that ideally you write code thats going to do exactly what you want to do the first time but that doesnt tend to happen so heres the challenge you write a piece of code you wanted to just nail it the first time and heres a little visual of how you like to expect it to happen wouldnt you like to be able to park like this young girl youd just nail it exactly right as you zero in on the right spot youd like your code to do it exactly right the first time but the reality is you set up a very complex piece of code and you start it up and it doesnt quite do what you want it so theres expectation and theres reality how do we get away from the thing on the right and get to the thing on the left which is what we really want to have happen here so we aim for high quality how do we get it there well im going to give you an analogy with making soup im going to acknowledge its a little bit of a queasy analogy but bear with me here youre making soup in the kitchen but bugs keep falling in from the ceiling so what do you do to make sure you have good soup i dont want to eat soup with bugs in it well you could check the soup for bugs you could keep the lid closed or you could clean the kitchen all good things to do and all of them have nice components in fact of testing and debugging checking for soup is the discipline of testing how do i test my code to see whether it in fact does what i expect it to do keeping the lid closed is what we call defensive programming were going to talk about that it is how do you structure your code how do you write code in a way that plans ahead to try and make sure that you avoid the bugs or at least detect them before you actually run the code and cleaning the kitchen just eliminate the source of bugs do the debugging to get it done thats what were going to talk about in this lecture so defensive programming at a high level basically has three parts the first one is to write specifications for the functions youre writing write out those doc strings that says here is what i expect coming in and heres what i will deliver if i get things that are of the right form second nice piece of defensive programming is to write modular programs dont write one really long huge single function break it up into obvious pieces those pieces are going to be valuable to us when we get around to actually testing because i can test each piece in turn and then finally under defensive programming i want to check the conditions on those inputs and outputs were going to see an example of that in a later lecture where we use assertions to actually formally do that but defensive programming basically comes down to defining what i expect to come in what ill deliver and then ensuring that i actually do that testing or validation really comes down to comparing inputs and outputs given a set of functions i want to test i should write a list of a set of example inputs and what i expect in each case as an output and then when i discover its not working figure out how to debug it i also want to ask a different kind of question which is how can i break my program what are the right kinds of inputs to use to make sure i test all of the different cases that are going to be important ensuring that my program is doing the right thing and finally with debugging once i have a bug what do i want to do mostly i want to look at the events that led up to the error what was going on before this error occurred and then ask two different kinds of questions one why is it not working whats causing that and then having found that how do i go ahead and fix it so it will work properly those are the tools that we want to have as we think about testing and debugging our code
lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei lorem ipsum dolor sit amet vide suavitate an mel ei sea vidit aliquando eam ornatus facilis vulputate no eum id meis admodum honestatis ex semper virtute accommodare usu mea inani labore oporteat an omnis accumsan moderatius cu nec pri melius apeirian cu ut has reque adversarium dissentiunt justo reprimique sea ea ne atqui affert philosophia est an eum dicant soluta usu at legere veritus novum menandri at vix elitr nonumy audire eos eu libris aliquip signiferumque sit ei
0.0

----------------------------------------
########## Testcase 1: Failed ##########
Expected Output: 
1.0

Your Output: 
weve been showing you a lot of great tools in computation weve introduced simple data objects weve introduced compound data objects weve introduced iteration weve introduced recursion weve talked about using functions in a variety of ways you now have a lot of the tools you need to have in order to build interesting code and in fact weve been asking to do that in the problem sets that you have been working on as youve gone through this course but we now come to a place where we have to be a little more clever because youve probably already experienced problems with your code bugs have wandered in that you werent expecting they have done things that you didnt want to have happen inside of the code and so were going to now turn to a question that every computer programmer faces which is how do i test my code and when it doesnt work the way i expected it to how do i go about debugging it and thats what this lectures going to be all about now one of the things that happens with debugging is that ideally you write code thats going to do exactly what you want to do the first time but that doesnt tend to happen so heres the challenge you write a piece of code you wanted to just nail it the first time and heres a little visual of how you like to expect it to happen wouldnt you like to be able to park like this young girl youd just nail it exactly right as you zero in on the right spot youd like your code to do it exactly right the first time but the reality is you set up a very complex piece of code and you start it up and it doesnt quite do what you want it so theres expectation and theres reality how do we get away from the thing on the right and get to the thing on the left which is what we really want to have happen here so we aim for high quality how do we get it there well im going to give you an analogy with making soup im going to acknowledge its a little bit of a queasy analogy but bear with me here youre making soup in the kitchen but bugs keep falling in from the ceiling so what do you do to make sure you have good soup i dont want to eat soup with bugs in it well you could check the soup for bugs you could keep the lid closed or you could clean the kitchen all good things to do and all of them have nice components in fact of testing and debugging checking for soup is the discipline of testing how do i test my code to see whether it in fact does what i expect it to do keeping the lid closed is what we call defensive programming were going to talk about that it is how do you structure your code how do you write code in a way that plans ahead to try and make sure that you avoid the bugs or at least detect them before you actually run the code and cleaning the kitchen just eliminate the source of bugs do the debugging to get it done thats what were going to talk about in this lecture so defensive programming at a high level basically has three parts the first one is to write specifications for the functions youre writing write out those doc strings that says here is what i expect coming in and heres what i will deliver if i get things that are of the right form second nice piece of defensive programming is to write modular programs dont write one really long huge single function break it up into obvious pieces those pieces are going to be valuable to us when we get around to actually testing because i can test each piece in turn and then finally under defensive programming i want to check the conditions on those inputs and outputs were going to see an example of that in a later lecture where we use assertions to actually formally do that but defensive programming basically comes down to defining what i expect to come in what ill deliver and then ensuring that i actually do that testing or validation really comes down to comparing inputs and outputs given a set of functions i want to test i should write a list of a set of example inputs and what i expect in each case as an output and then when i discover its not working figure out how to debug it i also want to ask a different kind of question which is how can i break my program what are the right kinds of inputs to use to make sure i test all of the different cases that are going to be important ensuring that my program is doing the right thing and finally with debugging once i have a bug what do i want to do mostly i want to look at the events that led up to the error what was going on before this error occurred and then ask two different kinds of questions one why is it not working whats causing that and then having found that how do i go ahead and fix it so it will work properly those are the tools that we want to have as we think about testing and debugging our code
weve been showing you a lot of great tools in computation weve introduced simple data objects weve introduced compound data objects weve introduced iteration weve introduced recursion weve talked about using functions in a variety of ways you now have a lot of the tools you need to have in order to build interesting code and in fact weve been asking to do that in the problem sets that you have been working on as youve gone through this course but we now come to a place where we have to be a little more clever because youve probably already experienced problems with your code bugs have wandered in that you werent expecting they have done things that you didnt want to have happen inside of the code and so were going to now turn to a question that every computer programmer faces which is how do i test my code and when it doesnt work the way i expected it to how do i go about debugging it and thats what this lectures going to be all about now one of the things that happens with debugging is that ideally you write code thats going to do exactly what you want to do the first time but that doesnt tend to happen so heres the challenge you write a piece of code you wanted to just nail it the first time and heres a little visual of how you like to expect it to happen wouldnt you like to be able to park like this young girl youd just nail it exactly right as you zero in on the right spot youd like your code to do it exactly right the first time but the reality is you set up a very complex piece of code and you start it up and it doesnt quite do what you want it so theres expectation and theres reality how do we get away from the thing on the right and get to the thing on the left which is what we really want to have happen here so we aim for high quality how do we get it there well im going to give you an analogy with making soup im going to acknowledge its a little bit of a queasy analogy but bear with me here youre making soup in the kitchen but bugs keep falling in from the ceiling so what do you do to make sure you have good soup i dont want to eat soup with bugs in it well you could check the soup for bugs you could keep the lid closed or you could clean the kitchen all good things to do and all of them have nice components in fact of testing and debugging checking for soup is the discipline of testing how do i test my code to see whether it in fact does what i expect it to do keeping the lid closed is what we call defensive programming were going to talk about that it is how do you structure your code how do you write code in a way that plans ahead to try and make sure that you avoid the bugs or at least detect them before you actually run the code and cleaning the kitchen just eliminate the source of bugs do the debugging to get it done thats what were going to talk about in this lecture so defensive programming at a high level basically has three parts the first one is to write specifications for the functions youre writing write out those doc strings that says here is what i expect coming in and heres what i will deliver if i get things that are of the right form second nice piece of defensive programming is to write modular programs dont write one really long huge single function break it up into obvious pieces those pieces are going to be valuable to us when we get around to actually testing because i can test each piece in turn and then finally under defensive programming i want to check the conditions on those inputs and outputs were going to see an example of that in a later lecture where we use assertions to actually formally do that but defensive programming basically comes down to defining what i expect to come in what ill deliver and then ensuring that i actually do that testing or validation really comes down to comparing inputs and outputs given a set of functions i want to test i should write a list of a set of example inputs and what i expect in each case as an output and then when i discover its not working figure out how to debug it i also want to ask a different kind of question which is how can i break my program what are the right kinds of inputs to use to make sure i test all of the different cases that are going to be important ensuring that my program is doing the right thing and finally with debugging once i have a bug what do i want to do mostly i want to look at the events that led up to the error what was going on before this error occurred and then ask two different kinds of questions one why is it not working whats causing that and then having found that how do i go ahead and fix it so it will work properly those are the tools that we want to have as we think about testing and debugging our code
1.0

----------------------------------------
########## Testcase 2: Failed ##########
Expected Output: 
0.4425012603813615

Your Output: 
weve been showing you a lot of great tools in computation weve introduced simple data objects weve introduced compound data objects weve introduced iteration weve introduced recursion weve talked about using functions in a variety of ways you now have a lot of the tools you need to have in order to build interesting code and in fact weve been asking to do that in the problem sets that you have been working on as youve gone through this course but we now come to a place where we have to be a little more clever because youve probably already experienced problems with your code bugs have wandered in that you werent expecting they have done things that you didnt want to have happen inside of the code and so were going to now turn to a question that every computer programmer faces which is how do i test my code and when it doesnt work the way i expected it to how do i go about debugging it and thats what this lectures going to be all about now one of the things that happens with debugging is that ideally you write code thats going to do exactly what you want to do the first time but that doesnt tend to happen so heres the challenge you write a piece of code you wanted to just nail it the first time and heres a little visual of how you like to expect it to happen wouldnt you like to be able to park like this young girl youd just nail it exactly right as you zero in on the right spot youd like your code to do it exactly right the first time but the reality is you set up a very complex piece of code and you start it up and it doesnt quite do what you want it so theres expectation and theres reality how do we get away from the thing on the right and get to the thing on the left which is what we really want to have happen here so we aim for high quality how do we get it there well im going to give you an analogy with making soup im going to acknowledge its a little bit of a queasy analogy but bear with me here youre making soup in the kitchen but bugs keep falling in from the ceiling so what do you do to make sure you have good soup i dont want to eat soup with bugs in it well you could check the soup for bugs you could keep the lid closed or you could clean the kitchen all good things to do and all of them have nice components in fact of testing and debugging checking for soup is the discipline of testing how do i test my code to see whether it in fact does what i expect it to do keeping the lid closed is what we call defensive programming were going to talk about that it is how do you structure your code how do you write code in a way that plans ahead to try and make sure that you avoid the bugs or at least detect them before you actually run the code and cleaning the kitchen just eliminate the source of bugs do the debugging to get it done thats what were going to talk about in this lecture so defensive programming at a high level basically has three parts the first one is to write specifications for the functions youre writing write out those doc strings that says here is what i expect coming in and heres what i will deliver if i get things that are of the right form second nice piece of defensive programming is to write modular programs dont write one really long huge single function break it up into obvious pieces those pieces are going to be valuable to us when we get around to actually testing because i can test each piece in turn and then finally under defensive programming i want to check the conditions on those inputs and outputs were going to see an example of that in a later lecture where we use assertions to actually formally do that but defensive programming basically comes down to defining what i expect to come in what ill deliver and then ensuring that i actually do that testing or validation really comes down to comparing inputs and outputs given a set of functions i want to test i should write a list of a set of example inputs and what i expect in each case as an output and then when i discover its not working figure out how to debug it i also want to ask a different kind of question which is how can i break my program what are the right kinds of inputs to use to make sure i test all of the different cases that are going to be important ensuring that my program is doing the right thing and finally with debugging once i have a bug what do i want to do mostly i want to look at the events that led up to the error what was going on before this error occurred and then ask two different kinds of questions one why is it not working whats causing that and then having found that how do i go ahead and fix it so it will work properly those are the tools that we want to have as we think about testing and debugging our code
in our programs we generally find problems where our code didnt work as we wanted it to work those problems are bugs and this video teaches how to identify debug and f